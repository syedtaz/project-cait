var documenterSearchIndex = {"docs":
[{"location":"usage/#Usage","page":"Usage","title":"Usage","text":"","category":"section"},{"location":"usage/","page":"Usage","title":"Usage","text":"There are two main ways of using this package. You can either write your own Julia driver code (or any language that can inferface with Julia) in either a separate script or use an interactive environment such as the Julia REPL or Jupyter/Pluto. In this case, we are assuming you are using the REPL, but there should be minimal differences in using a notebook.","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"Initiate the Julia REPL by calling julia from the terminal or launching the Julia application. If you are using the CLI, please see this link to ensure that your PATH variables are set up properly.","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"The program assumes that you are in the /project-cait/ directory. You can either cd from the REPL itself or launch it from that directory. You will then have to load the files by running","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"> include(\"src/simulator.jl\")","category":"page"},{"location":"usage/#Compilation","page":"Usage","title":"Compilation","text":"","category":"section"},{"location":"usage/","page":"Usage","title":"Usage","text":"Julia is just-in-time compiled – which means that the system will only compile code when needed. Usually, this means that only parts of a program that you use are compiled when you call them. So the very first time you run any function from this package (in a fresh Julia session) it will take some time to compile but every use afterwards (until you close the session) will be much faster. Conside looking into Revise.jl and related documentation online on how to manage Julia REPL sessions and compilation times.","category":"page"},{"location":"usage/#Dependencies","page":"Usage","title":"Dependencies","text":"","category":"section"},{"location":"usage/","page":"Usage","title":"Usage","text":"When you run the include code, Julia will load all of the externed .jl into the current scope. If there are scripts that require other packages, Julia will download and install the required dependencies from the project.toml if you run activate . and instantiate from inside the Julia package manager. However, I recommend just installing the dependencies manually for now. ","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"You can enter the pkg mode in the repl by typing ] followed by a space. From there you should run the following commands:","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"> add DataStructures\n> add Parameters\n> add JLD2\n> add StaticArrays","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"This should install and precompile the dependencies. It is probably a good idea to install them into a separate environment (similiar to Python's virtualenv or conda environments). See here for details.","category":"page"},{"location":"usage/#Implementation","page":"Usage","title":"Implementation","text":"","category":"section"},{"location":"usage/","page":"Usage","title":"Usage","text":"The automata.jl file defines two structs Model and Cell. The Model can contain a vector of cells as well as an array of functions that map to every reaction and an array of reaction effects. The code comes with a convenient function to instantiate the model with identical cells, but there is nothing stopping you from creating an initial state of your choosing. It also comes with the reaction-function mapping (proprules) and effects (stoichiometry) but it is possible to change these reaction dynamics or add your own.","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"The Cell contains all the necessary elements for for tracking its internal state (reactants, reaction rates, etc) as well as those for the Next Reaction Method such as internal time vectors, propensity vectors, priority queues for delayed and non-delayed reactions as well. For plotting, the levels vector contains the concentration of whichever reactant you want to measure (set to mh1 by default) and the Time vector contains the corresponding timestamp.","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"The dependency graph for the associated reactions have been generated and stored in .jld2 file which is loaded automatically. As of right now there is no way to dynamically generate the dependency graph. You can use the JLD2 package to open and decrypt the graph if you want to.","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"The nrm file contains modular functions for the Next Reaction Method algorithm and simulator contains driver code that runs the algorithm itself. Beyond that, please see the associated papers and docstrings in the source files: they are pretty straightforward and map the pseudocode in the paper to Julia code. ","category":"page"},{"location":"usage/#Running","page":"Usage","title":"Running","text":"","category":"section"},{"location":"usage/","page":"Usage","title":"Usage","text":"The main function in simulator is nrm. This function takes in the number of cells you want, the simulation time in seconds and a vector of reaction rates. The defaults are set to one cell for 0.05s. It returns a Model containing cells, and each cell contains their own internal vectors containing the levels of the reactans at each timestep. If you want to simulate two cells for 100s using the default rates, run","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"model = nrm(2,100)","category":"page"},{"location":"usage/#Plotting","page":"Usage","title":"Plotting","text":"","category":"section"},{"location":"usage/","page":"Usage","title":"Usage","text":"Ensure you have the standard plotting library installed, and load it into your session by running","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"> using Plots","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"You can then access the cells in your model and then plot the fields you want. For example, the following code will print the graph for the first cell in the model.","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"> plot(model.cells[1].Time, model.cells[1].levels)","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"If you are running this on AWS servers, you need to set the backend to unicodeplots() in order to plot the graph on the terminal. On macOS, the plots are generated in GTK+ by default. ","category":"page"},{"location":"algorithm/#Algorithm","page":"Algorithm","title":"Algorithm","text":"","category":"section"},{"location":"algorithm/","page":"Algorithm","title":"Algorithm","text":"Currently the package supports a delayed stochastic simulation system using a modified next reaction method to model the zebrafish MRNA concentrations. Please see Ay & Ozubdak[1] for more details on the research project – this page only contains a brief overview.","category":"page"},{"location":"algorithm/#Next-Reaction-Method","page":"Algorithm","title":"Next Reaction Method","text":"","category":"section"},{"location":"algorithm/","page":"Algorithm","title":"Algorithm","text":"Please see Anderson[2] for a theoretical and language agnostic discussion on the algorithm implemented in this package. ","category":"page"},{"location":"algorithm/#Terminology","page":"Algorithm","title":"Terminology","text":"","category":"section"},{"location":"algorithm/","page":"Algorithm","title":"Algorithm","text":"t refers to the current time in the system\nFor any reaction k\nP_k refers to the propensity of the reaction\nT_k refers to the internal time  the reaction\na_k refers to the propensity function  the reaction\nr_k refers to the mathcalU(01) random number generated for  the reaction\nS_k refers to the completion time channel of the reaction (only if it is a delayed reaction)\nND refers to reactions that have no delays. Their effects are applied immediately.\nCD refer to reactions that have a delay but their change is applied when the reaction is completed.\nICD refers to reactions that change the state of the system both when they initiate and when they complete.","category":"page"},{"location":"algorithm/#Pseudocode","page":"Algorithm","title":"Pseudocode","text":"","category":"section"},{"location":"algorithm/","page":"Algorithm","title":"Algorithm","text":"Set the initial number of reactants and set t=0. For every reaction k, set P_k and T_k to zero and initialize S_k = infty if it is a delayed reaction.\nFor each reaction k,\nCalculate the propensity functions a_k.\nGenerate r_k and set P_k = lndfrac1r_k.\nSet Delta t_k = (P_k - T_k)a_k\nSet Delta = min(Delta t_k s_k(1) - t)\nIncrement t by Delta.\nLet mu be the reaction we chose. \nIf we are completing a ICD reaction apply the effect of the reaction and delete the first element of s_mu.\nIf we are initiating a non-delayed reaction, apply the effect of the reaction immediately.\nIf we are initiating a CD reaction, update s_mu by inserting t + tau_mu into s_mu in the second to last position.\nIf we are initiating an ICD reaction, apply the initiation effects of the reaction and update s_mu by inserting t + tau_mu into s_mu in the second to last position.\nFor each reaction k, set T_k = T_k + a_k cdot Delta. \nIf reaction mu was initiated, let r be mathcalU(01) and increment P_mu by lndfrac1r.\nGo to step 2, or quit.","category":"page"},{"location":"algorithm/#Rejection-/-Direct-Method","page":"Algorithm","title":"Rejection / Direct Method","text":"","category":"section"},{"location":"algorithm/","page":"Algorithm","title":"Algorithm","text":"These algorithms were tried out but were not generally as fast or readable as NRM. Stable and efficient versions might be added in the future.","category":"page"},{"location":"algorithm/","page":"Algorithm","title":"Algorithm","text":"[1]: Ay A, Knierer S, Sperlea A, Holland J, Özbudak EM. Short-lived Her proteins drive robust synchronized oscillations in the zebrafish segmentation clock. Development. 2013 Aug;140(15):3244-53. doi: 10.1242/dev.093278. PMID: 23861061.","category":"page"},{"location":"algorithm/","page":"Algorithm","title":"Algorithm","text":"[2]: J. Chem. Phys. 127, 214107 (2007); https://doi.org/10.1063/1.2799998","category":"page"},{"location":"#caitlyn.jl","page":"Home","title":"caitlyn.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Code for stochastically simulating oscillatory systems in multicellular models of zebrafish. Current iterations include a stable, tested CPU version written in Julia and an unstable low-level version in CUDA C. Code by Tazmilur Saad.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package is not available on Julia's registries and must be installed manually. You can clone the repository using:","category":"page"},{"location":"","page":"Home","title":"Home","text":"git clone https://github.com/syedtaz/project-cait.git","category":"page"},{"location":"","page":"Home","title":"Home","text":"Currently, this package has been tested for Julia 1.5.0 but it should work on the latest releases. Please see this link on how to install Julia. Once installed, you can launch the program by entering the Julia REPL and loading the package using","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> include(\"src/simulator.jl\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"This will load all of the functions of the package into the REPL scope. If there are dependencies that are not present on your system Julia's package manager will download and precompile them. ","category":"page"},{"location":"#Quickstart","page":"Home","title":"Quickstart","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The following code will create a 1-cell model with 100 seconds of simulation time using the default reactants and rate parameters.","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> model = nrm(1,100)","category":"page"},{"location":"","page":"Home","title":"Home","text":"You can plot this using Plots.jl. For example, the following code snippet will plot the cell contents vs time, using your system's default plotting backend (GTK+ on macOS). If you are running this code on AWS / any other remote environment, you should use the unicodeplots() backend.","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Plots\nplot(model.cells[1].Time, model.cells[1].levels)","category":"page"},{"location":"","page":"Home","title":"Home","text":"This is one of the possible outputs.","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: )","category":"page"},{"location":"#Acknowledgements","page":"Home","title":"Acknowledgements","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Thanks to Professor Ahmet Ay for guiding this project.","category":"page"}]
}
